set.seed = 42
# Given a statistical model of probability density and a sample of i.i.d
# observations, the likelihood of observing the whole sample is defined as the
# product of the probability densities of the individual values. The goal of MLE
# is to find the parameters of the statistical model that maximize the
# likelihood of observing the whole sample.
# MLE converges asymptotically to the true parameters of the population as the
# sample size increases.
# Normal distribution function.
normal <- function(x, mu, sigma) {
(1 / (sqrt(2 * pi * sigma^2))) * (exp((-(x - mu)^2) / (2 * sigma^2)))
}
# Generate 10000 values from a N(1, 2) distribution.
sample <- rnorm(10000, mean = 1, sd = 2)
# The objective is to minimize negative log likelihood (NLL).
nll <- function(pars, data) {
mu = pars[1]
sigma = pars[2]
-sum(log(normal(x = data, mu, sigma)))
#-sum(dnorm(x = data, mean = mu, sd = sigma, log = TRUE))
}
# Writing a super naive optimization function.
mle <- function(x, n_iters, init.mu, init.sigma, mu.scope, sigma.scope, granularity, scope.shrinkage) {
test.mu <- init.mu
test.sigma <- init.sigma
for (n in 1:n_iters) {
# Create vectors of test mu and sigma values.
pars <- cbind(
seq(
from = (test.mu - mu.scope),
to = (test.mu + mu.scope),
length.out = granularity
),
seq(
from = (test.sigma - sigma.scope),
to = (test.sigma + sigma.scope),
length.out = granularity
)
)
nll_score <- vector(mode = "numeric", length = nrow(pars))
for (i in 1:nrow(pars)) {
nll_score[[i]] <- nll(pars[i, ], x)
}
print(nll_score)
print(which.min(nll_score))
# Find new optimal mu and sigma
test.mu <- pars[which.min(nll_score), 1]
test.sigma <- pars[which.min(nll_score), 2]
print(paste0(
"current mu = ", round(test.mu, 3),
", current sigma = ", round(test.sigma, 3))
)
# Apply search window shrinkage.
mu.scope <- mu.scope * scope.shrinkage
sigma.scope <- sigma.scope * scope.shrinkage
}
return(c(test.mu, test.sigma))
}
# Writing a super naive optimization function.
mle <- function(x, n_iters, init.mu, init.sigma, mu.scope, sigma.scope, granularity, scope.shrinkage) {
test.mu <- init.mu
test.sigma <- init.sigma
for (n in 1:n_iters) {
# Create vectors of test mu and sigma values.
pars <- cbind(
seq(
from = (test.mu - mu.scope),
to = (test.mu + mu.scope),
length.out = granularity
),
seq(
from = (test.sigma - sigma.scope),
to = (test.sigma + sigma.scope),
length.out = granularity
)
)
nll_score <- vector(mode = "numeric", length = nrow(pars))
for (i in 1:nrow(pars)) {
nll_score[[i]] <- nll(pars[i, ], x)
}
# Find new optimal mu and sigma
test.mu <- pars[which.min(nll_score), 1]
test.sigma <- pars[which.min(nll_score), 2]
print(paste0(
"current mu = ", round(test.mu, 3),
", current sigma = ", round(test.sigma, 3))
)
# Apply search window shrinkage.
mu.scope <- mu.scope * scope.shrinkage
sigma.scope <- sigma.scope * scope.shrinkage
}
return(c(test.mu, test.sigma))
}
mle(x = sample, n_iters = 10, init.mu = 0, init.sigma = 1, mu.scope = 5,
sigma.scope = 5, granularity = 100, scope.shrinkage = 0.5)
# Generate 10000 values from a N(1, 2) distribution.
sample <- rnorm(10000, mean = 2, sd = 4)
# Writing a super naive optimization function.
mle <- function(x, n_iters, init.mu, init.sigma, mu.scope, sigma.scope, granularity, scope.shrinkage) {
test.mu <- init.mu
test.sigma <- init.sigma
for (n in 1:n_iters) {
# Create vectors of test mu and sigma values.
pars <- cbind(
seq(
from = (test.mu - mu.scope),
to = (test.mu + mu.scope),
length.out = granularity
),
seq(
from = (test.sigma - sigma.scope),
to = (test.sigma + sigma.scope),
length.out = granularity
)
)
nll_score <- vector(mode = "numeric", length = nrow(pars))
for (i in 1:nrow(pars)) {
nll_score[[i]] <- nll(pars[i, ], x)
}
# Find new optimal mu and sigma
test.mu <- pars[which.min(nll_score), 1]
test.sigma <- pars[which.min(nll_score), 2]
print(paste0(
"current mu = ", round(test.mu, 3),
", current sigma = ", round(test.sigma, 3))
)
# Apply search window shrinkage.
mu.scope <- mu.scope * scope.shrinkage
sigma.scope <- sigma.scope * scope.shrinkage
}
return(c(test.mu, test.sigma))
}
mle(x = sample, n_iters = 10, init.mu = 0, init.sigma = 1, mu.scope = 5,
sigma.scope = 5, granularity = 100, scope.shrinkage = 0.5)
mle(x = sample, n_iters = 10, init.mu = 0, init.sigma = 1, mu.scope = 10,
sigma.scope = 10, granularity = 100, scope.shrinkage = 0.5)
mle(x = sample, n_iters = 10, init.mu = 1, init.sigma = 2, mu.scope = 10,
sigma.scope = 10, granularity = 100, scope.shrinkage = 0.5)
# Generate 10000 values from a N(1, 2) distribution.
sample <- rnorm(10000, mean = 1, sd = 3)
mle(x = sample, n_iters = 10, init.mu = 1, init.sigma = 2, mu.scope = 10,
sigma.scope = 10, granularity = 100, scope.shrinkage = 0.5)
set.seed = 42
# Normal distribution function.
normal <- function(x, mu, sigma) {
(1 / (sqrt(2 * pi * sigma^2))) * (exp((-(x - mu)^2) / (2 * sigma^2)))
}
# Generate 10000 values from a N(1, 2) distribution.
sample <- rnorm(10000, mean = 1, sd = 3)
# The objective is to minimize negative log likelihood (NLL).
nll <- function(pars, data) {
mu = pars[1]
sigma = pars[2]
-sum(log(normal(x = data, mu, sigma)))
#-sum(dnorm(x = data, mean = mu, sd = sigma, log = TRUE))
}
# Writing a super naive optimization function.
mle <- function(x, n_iters, init.mu, init.sigma, mu.scope, sigma.scope, granularity, scope.shrinkage) {
test.mu <- init.mu
test.sigma <- init.sigma
for (n in 1:n_iters) {
# Create vectors of test mu and sigma values.
pars <- cbind(
seq(
from = (test.mu - mu.scope),
to = (test.mu + mu.scope),
length.out = granularity
),
seq(
from = (test.sigma - sigma.scope),
to = (test.sigma + sigma.scope),
length.out = granularity
)
)
nll_score <- vector(mode = "numeric", length = nrow(pars))
for (i in 1:nrow(pars)) {
nll_score[[i]] <- nll(pars[i, ], x)
}
# Find new optimal mu and sigma
test.mu <- pars[which.min(nll_score), 1]
test.sigma <- pars[which.min(nll_score), 2]
print(paste0(
"current mu = ", round(test.mu, 3),
", current sigma = ", round(test.sigma, 3))
)
# Apply search window shrinkage.
mu.scope <- mu.scope * scope.shrinkage
sigma.scope <- sigma.scope * scope.shrinkage
}
return(c(test.mu, test.sigma))
}
mle(x = sample, n_iters = 10, init.mu = 1, init.sigma = 2, mu.scope = 10,
sigma.scope = 10, granularity = 100, scope.shrinkage = 0.5)
NLL = function(pars, data) {
# Extract parameters from the vector
mu = pars[1]
sigma = pars[2]
# Calculate Negative Log-LIkelihood
-sum(dnorm(x = data, mean = mu, sd = sigma, log = TRUE))
}
mle = optim(par = c(mu = 0.2, sigma = 1.5), fn = NLL, data = sample,
control = list(parscale = c(mu = 0.2, sigma = 1.5)))
mle$par
# Writing a super naive optimization function.
mle <- function(x, n_iters, init.mu, init.sigma, mu.scope, sigma.scope, granularity, scope.shrinkage) {
test.mu <- init.mu
test.sigma <- init.sigma
for (n in 1:n_iters) {
# Create vectors of test mu and sigma values.
pars <- cbind(
seq(
from = (test.mu - mu.scope),
to = (test.mu + mu.scope),
length.out = granularity
),
seq(
from = (test.sigma - sigma.scope),
to = (test.sigma + sigma.scope),
length.out = granularity
)
)
nll_score <- vector(mode = "numeric", length = nrow(pars))
for (i in 1:nrow(pars)) {
nll_score[[i]] <- nll(pars[i, ], x)
}
# Find new optimal mu and sigma
test.mu <- pars[which.min(nll_score), 1]
test.sigma <- pars[which.min(nll_score), 2]
print(paste0(
"current mu = ", round(test.mu, 3),
", current sigma = ", round(test.sigma, 3))
)
# Apply search window shrinkage.
mu.scope <- mu.scope * scope.shrinkage
sigma.scope <- sigma.scope * scope.shrinkage
}
return(c(test.mu, test.sigma))
}
mle(x = sample, n_iters = 10, init.mu = 1, init.sigma = 3, mu.scope = 10,
sigma.scope = 10, granularity = 100, scope.shrinkage = 0.5)
mle(x = sample, n_iters = 10, init.mu = 1, init.sigma = 2, mu.scope = 10,
sigma.scope = 10, granularity = 100, scope.shrinkage = 0.5)
mle(x = sample, n_iters = 5, init.mu = 1, init.sigma = 2, mu.scope = 5,
sigma.scope = 5, granularity = 100, scope.shrinkage = 0.75)
mle(x = sample, n_iters = 1, init.mu = 1, init.sigma = 2, mu.scope = 5,
sigma.scope = 5, granularity = 100, scope.shrinkage = 0.75)
mle(x = sample, n_iters = 1, init.mu = 1, init.sigma = 2, mu.scope = 5,
sigma.scope = 5, granularity = 1000, scope.shrinkage = 0.75)
mle(x = sample, n_iters = 1, init.mu = 0, init.sigma = 1, mu.scope = 5,
sigma.scope = 5, granularity = 100, scope.shrinkage = 0.75)
# Generate 10000 values from a N(1, 2) distribution.
sample <- rnorm(10000, mean = 1, sd = 2)
mle(x = sample, n_iters = 1, init.mu = 0, init.sigma = 1, mu.scope = 5,
sigma.scope = 5, granularity = 100, scope.shrinkage = 0.75)
# Test performance relative to MLE that uses the dnorm function and
# Nelder-Mead simplex optimization.
NLL = function(pars, data) {
mu = pars[1]
sigma = pars[2]
-sum(dnorm(x = data, mean = mu, sd = sigma, log = TRUE))
}
optim(par = c(mu = 0, sigma = 1), fn = NLL, data = sample,
control = list(parscale = c(mu = 0, sigma = 1)))
optim(par = c(mu = 1, sigma = 1), fn = NLL, data = sample,
control = list(parscale = c(mu = 1, sigma = 1)))
# Test performance relative to MLE that uses the dnorm function and
# Nelder-Mead simplex optimization.
benchmark_nll = function(pars, data) {
mu = pars[1]
sigma = pars[2]
-sum(dnorm(x = data, mean = mu, sd = sigma, log = TRUE))
}
benchmark_mle <- optim(par = c(mu = 1, sigma = 1), fn = benchmark_nll, data = sample,
control = list(parscale = c(mu = 1, sigma = 1)))
benchmark_mle$par
# Run MLE.
mle(x = sample, n_iters = 1, init.mu = 0, init.sigma = 1, mu.scope = 5,
sigma.scope = 5, granularity = 100, scope.shrinkage = 0.75)
?dnorm
?oos_realized_forc
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
library(devtools)
library(available)
library(rhub)
library(testthat)
setwd("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
library(devtools)
library(available)
library(rhub)
library(testthat)
setwd("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
my_forecast <- Forecast(
origin   = as.Date(c("2010-03-31", "2010-06-30", "2010-09-30", "2010-12-31")),
future   = as.Date(c("2011-03-31", "2011-06-30", "2011-09-30", "2011-12-31")),
forecast = c(4.21, 4.27, 5.32, 5.11),
realized = c(4.40, 4.45, 4.87, 4.77),
h_ahead  = 4L
)
mse(my_forcast)
mse(my_forecast)
rmse(my_forecast)
mae(my_forecast)
mape(my_forecast)
R2(my_forecast)
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
mape(my_forecast)
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
mape(my_forecast)
library(devtools)
library(available)
library(rhub)
library(testthat)
setwd("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
my_forecast <- Forecast(
origin   = as.Date(c("2010-03-31", "2010-06-30", "2010-09-30", "2010-12-31")),
future   = as.Date(c("2011-03-31", "2011-06-30", "2011-09-30", "2011-12-31")),
forecast = c(4.21, 4.27, 5.32, 5.11),
realized = c(4.40, 4.45, 4.87, 4.77),
h_ahead  = 4L
)
mse(my_forecast)
rmse(my_forecast)
mae(my_forecast)
mape(my_forecast)
R2(my_forecast)
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
mape(my_forecast)
MLmetrics::MAPE(forc(my_forecast), realized(my_forecast))
library(devtools)
library(available)
library(rhub)
library(testthat)
setwd("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
#===============================================================================
# Compile Updated Package
#===============================================================================
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
mape
?mape
my_forecast <- Forecast(
origin   = as.Date(c("2010-03-31", "2010-06-30", "2010-09-30", "2010-12-31")),
future   = as.Date(c("2011-03-31", "2011-06-30", "2011-09-30", "2011-12-31")),
forecast = c(4.21, 4.27, 5.32, 5.11),
realized = c(4.40, 4.45, 4.87, 4.77),
h_ahead  = 4L
)
mape(my_forecast)
MLmetrics::MAPE(forc(my_forecast), realized(my_forecast))
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
mape(my_forecast)
library(devtools)
library(available)
library(rhub)
library(testthat)
setwd("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
#===============================================================================
# Compile Updated Package
#===============================================================================
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
# Compile package documentation.
devtools::document()
# Build vignette.
# Note* to edit the vignette, edit the file /vignettes/lmForc.Rmd
devtools::build_vignettes()
vignette("lmForc", package = "lmForc")
my_forecast <- Forecast(
origin   = as.Date(c("2010-03-31", "2010-06-30", "2010-09-30", "2010-12-31")),
future   = as.Date(c("2011-03-31", "2011-06-30", "2011-09-30", "2011-12-31")),
forecast = c(4.21, 4.27, 5.32, 5.11),
realized = c(4.40, 4.45, 4.87, 4.77),
h_ahead  = 4L
)
mse(my_forecast)
rmse(my_forecast)
mae(my_forecast)
mape(my_forecast)
R2(my_forecast)
my_forecast <- Forecast(
origin   = as.Date(c("2010-03-31", "2010-06-30", "2010-09-30", "2010-12-31")),
future   = as.Date(c("2011-03-31", "2011-06-30", "2011-09-30", "2011-12-31")),
forecast = c(4.21, 4.27, 5.32, 5.11),
realized = c(4.40, 4.45, 4.87, NA),
h_ahead  = 4L
)
mse(my_forecast)
forc(my_forecast)
realized(my_forecast)
na.rm(realized(my_forecast))
realized(my_forecast)
Forecast <- my_forecast
forc(Forecast)
realized(Forecast)
is.na(realized(Forecast))
is.na(forc(Forecast))
my_forecast <- Forecast(
origin   = as.Date(c("2010-03-31", "2010-06-30", "2010-09-30", "2010-12-31")),
future   = as.Date(c("2011-03-31", "2011-06-30", "2011-09-30", "2011-12-31")),
forecast = c(NA, 4.27, 5.32, 5.11),
realized = c(4.40, 4.45, 4.87, NA),
h_ahead  = 4L
)
my_forecast <- Forecast(
origin   = as.Date(c("2010-03-31", "2010-06-30", "2010-09-30", "2010-12-31", "2011-01-01", "2011-01-02")),
future   = as.Date(c("2011-03-31", "2011-06-30", "2011-09-30", "2011-12-31", "2011-01-02", "2011-01-03")),
forecast = c(NA, 4.21, 4.27, 5.32, 5.11, 5.11),
realized = c(4.40, 4.40, 4.45, 4.87, 4.77, NA),
h_ahead  = 4L
)
is.na(forc(Forecast))
is.na(realized(Forecast))
Forecast <- my_forecast
is.na(forc(Forecast))
is.na(realized(Forecast))
is.na(forc(Forecast)) | is.na(realized(Forecast))
!is.na(forc(Forecast)) | is.na(realized(Forecast))
forecast <- forc(Forecast)[!is.na(forc(Forecast)) | is.na(realized(Forecast))]
forecast <- forc(Forecast)[!is.na(forc(Forecast)) | !is.na(realized(Forecast))]
!is.na(forc(Forecast)) | !is.na(realized(Forecast))
forecast <- forc(Forecast)[!(is.na(forc(Forecast)) | is.na(realized(Forecast)))]
realized <- realized(Forecast)[!(is.na(forc(Forecast)) | is.na(realized(Forecast)))]
library(devtools)
library(available)
library(rhub)
library(testthat)
setwd("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
#===============================================================================
# Compile Updated Package
#===============================================================================
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
my_forecast <- Forecast(
origin   = as.Date(c("2010-03-31", "2010-06-30", "2010-09-30", "2010-12-31", "2011-01-01", "2011-01-02")),
future   = as.Date(c("2011-03-31", "2011-06-30", "2011-09-30", "2011-12-31", "2011-01-02", "2011-01-03")),
forecast = c(NA, 4.21, 4.27, 5.32, 5.11, 5.11),
realized = c(4.40, 4.40, 4.45, 4.87, 4.77, NA),
h_ahead  = 4L
)
mse(my_forecast)
rmse(my_forecast)
mae(my_forecast)
mape(my_forecast)
R2(my_forecast)
my_forecast <- Forecast(
origin   = as.Date(c("2010-03-31", "2010-06-30", "2010-09-30", "2010-12-31", "2011-01-01", "2011-01-02")),
future   = as.Date(c("2011-03-31", "2011-06-30", "2011-09-30", "2011-12-31", "2011-01-02", "2011-01-03")),
forecast = c(4.22, 4.21, 4.27, 5.32, 5.11, 5.11),
realized = c(4.40, 4.40, 4.45, 4.87, 4.77, NA),
h_ahead  = 4L
)
mse(my_forecast)
rmse(my_forecast)
mae(my_forecast)
mape(my_forecast)
R2(my_forecast)
my_forecast <- Forecast(
origin   = as.Date(c("2010-03-31", "2010-06-30", "2010-09-30", "2010-12-31", "2011-01-01", "2011-01-02")),
future   = as.Date(c("2011-03-31", "2011-06-30", "2011-09-30", "2011-12-31", "2011-01-02", "2011-01-03")),
forecast = c(4.22, 4.21, 4.27, NA, 5.11, 5.11),
realized = c(4.40, 4.40, NA, 4.87, 4.77, 5.22),
h_ahead  = 4L
)
mse(my_forecast)
rmse(my_forecast)
mae(my_forecast)
mape(my_forecast)
R2(my_forecast)
library(devtools)
library(available)
library(rhub)
library(testthat)
setwd("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
?mape
?mae
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
# Compile package documentation.
devtools::document()
?mae
?state_weighted_forc
?states_weighted_forc
vignette("lmForc", package = "lmForc")
?states_weighted_forc
library(devtools)
library(available)
library(rhub)
library(testthat)
setwd("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
# Load package.
devtools::load_all("/Users/nelsonrayl/Desktop/init/lmForc/lmForc")
# Compile package documentation.
devtools::document()
# Build vignette.
# Note* to edit the vignette, edit the file /vignettes/lmForc.Rmd
devtools::build_vignettes()
vignette("lmForc", package = "lmForc")
# Run expectation tests.
devtools::test()
